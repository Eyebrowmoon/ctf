from z3 import *

arr = [0x3C, 0xE3, 0x5A, 0x9E, 0x91, 0x13, 0x8C, 5, 0xE4, 0x2E,
0xA, 0x52, 0x3D, 0xD8, 0x7C, 0xF5, 0x9F, 0x4B, 0x9F,
6, 0xD7, 0xA8, 0xE9, 0xA0, 0xA6, 0x36, 0xA6, 0x49, 0x31,
0x36, 0x93, 8, 0xEB, 0x70, 0xEB, 0xBF, 0xDF, 0x28, 0x50,
0xD, 0x7B, 0xE8, 0x96, 0xFA, 0xE8, 0xB7, 0xA5, 0xDF,
0xC2, 0x4D, 0xF0, 0xB8, 0x3B, 0x78, 0x62, 0x72, 0xB7,
0x48, 0x16, 0x97, 0xF0, 0x19, 0x2D, 0x6B, 8, 0x5B, 0x9F,
0x94, 0x49, 0x87, 0xE6, 0x24, 0x37, 0x52, 0xEF, 0xB8]

def mem(addr):
  offset = addr - 0x87e4

  return arr[offset] + arr[offset + 1] * 0x100

s = Solver()

inputs = [ BitVec('x%d' % i, 16) for i in xrange(0x10) ]

s.add(((inputs[0] ^ 0x4936) + inputs[10]) + mem(0x87f2) == 0)
s.add(((inputs[1] ^ 0xfdf) * inputs[3] * inputs[4]) ^ mem(0x87f0) == 0)
s.add(((inputs[2] ^ 0xc7df) + (inputs[7] * inputs[6])) ^ mem(0x8804) == 0)
s.add(((inputs[3] ^ 0xc50b) + 0x14aa) ^ mem(0x880a) == 0)
s.add((inputs[4] * inputs[30]) ^ mem(0x880c) == 0)
s.add((inputs[6] + inputs[3] + inputs[5]) ^ mem(0x8808) == 0)
s.add(((inputs[6] + 0x5432) | 0x3008) ^ mem(0x8818) == 0)
s.add((inputs[7] + 0x1212) ^ mem(0x881e) == 0)
s.add((inputs[8] ^ 0x8703) ^ mem(0x8800) == 0)
s.add(((inputs[10] ^ 0xa52) + (inputs[9] + 0x4004)) ^ mem(0x881a) == 0)
s.add((inputs[11] + inputs[8]) ^ mem(0x8802) == 0)
s.add(inputs[12] ^ mem(0x8824) == 0)
s.add(((inputs[13] ^ 0x863c) + 0x1234) ^ mem(0x87e8) == 0)
s.add((inputs[4] + inputs[9] + inputs[14]) ^ mem(0x8816) == 0)
s.add(((inputs[15] & 0xf00) + inputs[0]) ^ mem(0x8826) == 0)

print s.check()

model = s.model()

payload = ''

for variable in inputs:
  val = model[variable]

  payload += hex(int(str(val)))[2:]


